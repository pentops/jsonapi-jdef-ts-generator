import { ImportDeclaration, Node, ScriptTarget } from 'typescript';
import { ts, ScriptKind } from 'ts-morph';
import { readFile } from 'node:fs/promises';
import { match, P } from 'ts-pattern';
import { GeneratedImportPath, IPlugin, IPluginFile, ManualExport, ManualImport, PluginConfig } from '../types';
import { getImportPath } from '../../fs-helpers';
import { createImportDeclaration, createNamedExportDeclaration } from '../../helpers';
import { GeneratedClientFunction, GeneratedSchema } from '../../generated-types';
import { PluginFileGeneratorConfig, PluginFileReader, WritableFile } from './types';

const { createPrinter, createSourceFile, factory, ListFormat, NewLineKind } = ts;

export const defaultPluginFileReader: PluginFileReader = (path) => readFile(path, { encoding: 'utf-8' });

export class BasePluginFile<
  TFileContentType = string,
  TConfig extends PluginFileGeneratorConfig<TFileContentType> = PluginFileGeneratorConfig<TFileContentType>,
  TPluginConfig extends PluginConfig<TFileContentType, TConfig> = PluginConfig<TFileContentType, TConfig>,
  TPlugin extends IPlugin<TFileContentType, TConfig, TPluginConfig> = IPlugin<TFileContentType, TConfig, TPluginConfig>,
> implements IPluginFile<TFileContentType, TConfig, TPluginConfig, TPlugin>
{
  readonly config: TConfig;
  readonly existingFileContent: Promise<TFileContentType | undefined>;
  readonly generatingPlugin: TPlugin;
  nodeList: Node[] = [];
  readonly typeImports: Set<string>;
  readonly clientImports: Set<string>;
  readonly manualImports: Map<string, ManualImport>;
  readonly manualExports: Map<string | undefined, ManualExport>;
  writePath: string;
  rawContent: string | undefined;
  pendingHeaderNodes: Node[] = [];
  pendingImportNodes: Node[] = [];
  generatedTypesImportConfiguration: GeneratedImportPath;
  generatedClientImportConfiguration: GeneratedImportPath;
  printer = createPrinter({ newLine: NewLineKind.LineFeed });

  constructor(
    generatingPlugin: TPlugin,
    config: TConfig,
    generatedTypesImportConfiguration: GeneratedImportPath,
    generatedClientImportConfiguration: GeneratedImportPath,
    builtFilePath: string,
  ) {
    this.generatingPlugin = generatingPlugin;
    this.config = config;
    this.generatedTypesImportConfiguration = generatedTypesImportConfiguration;
    this.generatedClientImportConfiguration = generatedClientImportConfiguration;
    this.typeImports = new Set();
    this.clientImports = new Set();
    this.manualImports = new Map();
    this.manualExports = new Map();
    this.writePath = builtFilePath;

    // Read the file
    this.existingFileContent = (
      this.config.readExistingFile
        ? this.config.readExistingFile(builtFilePath, this.config.directory, this.config.fileName)
        : (defaultPluginFileReader(
            builtFilePath,
            this.config.directory,
            this.config.fileName,
          ) as Promise<TFileContentType>)
    ).catch((err) => {
      console.warn(
        `[jdef-ts-generator]: plugin (${generatingPlugin.name}) failed to read existing file data ${builtFilePath}`,
        err,
      );

      return undefined;
    });
  }

  async getExistingFileContent() {
    try {
      return await this.existingFileContent;
    } catch {
      return undefined;
    }
  }

  generateHeading(comment?: string) {
    this.pendingHeaderNodes = [
      factory.createJSDocComment(
        comment ||
          `@generated by @pentops/jsonapi-jdef-ts-generator (Plugin: ${this.generatingPlugin.name}) - do not edit`,
      ),
      factory.createIdentifier('\n'),
      ...this.pendingHeaderNodes,
    ];
  }

  generateBlankLine(writeToFront?: boolean) {
    const node = factory.createIdentifier('\n');

    if (writeToFront) {
      this.nodeList.unshift(node);
    } else {
      this.nodeList.push(node);
    }
  }

  addImportToOtherGeneratedFile(
    file: IPluginFile<TFileContentType>,
    namedImports: string[] | undefined,
    typeOnlyNamedImports?: string[],
    defaultImport?: string,
  ) {
    if (file.config.directory === this.config.directory && file.config.fileName === this.config.fileName) {
      return;
    }

    this.addManualImport(
      getImportPath(file.config.directory, file.config.fileName, this.config.directory, this.config.fileName),
      namedImports,
      typeOnlyNamedImports,
      defaultImport,
    );
  }

  addManualImport(
    importPath: string,
    namedImports: string[] | undefined,
    typeOnlyNamedImports?: string[],
    defaultImport?: string,
  ) {
    const existingImport = this.manualImports.get(importPath);

    if (!existingImport) {
      this.manualImports.set(importPath, {
        namedImports,
        typeOnlyNamedImports,
        defaultImport,
      });
    } else {
      this.manualImports.set(importPath, {
        ...existingImport,
        defaultImport: defaultImport || existingImport.defaultImport,
        namedImports: namedImports
          ? Array.from(new Set([...(existingImport.namedImports || []), ...(namedImports || [])]))
          : existingImport.namedImports,
        typeOnlyNamedImports: typeOnlyNamedImports
          ? Array.from(new Set([...(existingImport.typeOnlyNamedImports || []), ...(typeOnlyNamedImports || [])]))
          : existingImport.typeOnlyNamedImports,
      });
    }
  }

  removeManualImport(importPath: string, namedImports: string[] | undefined, defaultImport?: string) {
    const existingImport = this.manualImports.get(importPath);

    if (!existingImport) {
      return;
    }

    this.manualImports.set(importPath, {
      ...existingImport,
      defaultImport: defaultImport === existingImport.defaultImport ? undefined : existingImport.defaultImport,
      namedImports: existingImport.namedImports?.filter(
        (namedImport) => !namedImports || !namedImports.includes(namedImport),
      ),
      typeOnlyNamedImports: existingImport.typeOnlyNamedImports?.filter(
        (namedImport) => !namedImports || !namedImports.includes(namedImport),
      ),
    });
  }

  removeImportToGeneratedFile(
    file: IPluginFile<TFileContentType>,
    namedImports: string[] | undefined,
    defaultImport?: string,
  ) {
    if (file.config.directory === this.config.directory && file.config.fileName === this.config.fileName) {
      return;
    }

    this.removeManualImport(
      getImportPath(file.config.directory, file.config.fileName, this.config.directory, this.config.fileName),
      namedImports,
      defaultImport,
    );
  }

  addManualExport(exportPath: string | undefined, manualExport: ManualExport) {
    const existingExport = this.manualExports.get(exportPath);

    if (!existingExport) {
      this.manualExports.set(exportPath, manualExport);
    } else {
      this.manualExports.set(
        exportPath,
        match(manualExport)
          .with({ wildcard: true }, () => manualExport)
          .with({ namedExports: P.not(P.nullish) }, (e) => {
            const existingNamedExports = match(existingExport)
              .with({ namedExports: P.not(P.nullish) }, (e) => e.namedExports)
              .otherwise(() => []);
            const existingTypeOnlyExports = match(existingExport)
              .with({ typeOnlyExports: P.not(P.nullish) }, (e) => e.typeOnlyExports)
              .otherwise(() => []);

            return {
              namedExports: Array.from(new Set([...existingNamedExports, ...(e.namedExports || [])])),
              typeOnlyExports: Array.from(new Set([...existingTypeOnlyExports, ...(e.typeOnlyExports || [])])),
            };
          })
          .otherwise(() => existingExport),
      );
    }
  }

  addGeneratedTypeImport(typeName: string) {
    this.typeImports.add(typeName);
  }

  addGeneratedClientImport(clientFunctionName: string) {
    this.clientImports.add(clientFunctionName);
  }

  setRawContent(content: string) {
    this.rawContent = content;
  }

  generateExports() {
    const exportNodes: Node[] = [];

    for (const [exportPath, exportConfig] of this.manualExports) {
      const node = match(exportConfig)
        .with({ wildcard: true }, () =>
          exportPath
            ? factory.createExportDeclaration(
                undefined,
                false,
                undefined,
                factory.createStringLiteral(exportPath, true),
              )
            : undefined,
        )
        .with({ namedExports: P.not(P.nullish) }, (e) =>
          e.namedExports.length
            ? createNamedExportDeclaration(exportPath, e.namedExports, e.typeOnlyExports)
            : undefined,
        )
        .otherwise(() => undefined);

      if (node) {
        exportNodes.push(node);
      }
    }

    this.addNodes(...exportNodes);
  }

  generateImports() {
    const importNodes: ImportDeclaration[] = [];

    if (this.typeImports.size) {
      const importPath = match(this.generatedTypesImportConfiguration)
        .with({ importPath: P.string }, (p) => p.importPath)
        .with({ fileName: P.string, directory: P.string }, ({ directory: d, fileName: f }) =>
          getImportPath(d, f, this.config.directory, this.config.fileName),
        )
        .otherwise(() => undefined);

      if (!importPath) {
        throw new Error(
          `[jdef-ts-generator](${this.generatingPlugin.name}): generatedTypesImportConfiguration is missing either importPath, or fileName and directory`,
        );
      }

      importNodes.push(createImportDeclaration(importPath, Array.from(this.typeImports)));
    }

    if (this.clientImports.size) {
      const importPath = match(this.generatedClientImportConfiguration)
        .with({ importPath: P.string }, (p) => p.importPath)
        .with({ fileName: P.string, directory: P.string }, ({ directory: d, fileName: f }) =>
          getImportPath(d, f, this.config.directory, this.config.fileName),
        )
        .otherwise(() => undefined);

      if (!importPath) {
        throw new Error(
          `[jdef-ts-generator](${this.generatingPlugin.name}): generatedClientImportConfiguration is missing either importPath, or fileName and directory`,
        );
      }

      importNodes.push(createImportDeclaration(importPath, Array.from(this.clientImports)));
    }

    if (this.manualImports.size) {
      for (const [importPath, { namedImports, typeOnlyNamedImports, defaultImport }] of this.manualImports) {
        importNodes.push(createImportDeclaration(importPath, namedImports, typeOnlyNamedImports, defaultImport));
      }
    }

    importNodes.sort((a, b) => {
      const aIdText = ts.isStringLiteral(a.moduleSpecifier) ? a.moduleSpecifier.text : '';
      const bIdText = ts.isStringLiteral(b.moduleSpecifier) ? b.moduleSpecifier.text : '';

      if (aIdText.startsWith('.') && !bIdText.startsWith('.')) {
        return 1;
      }

      if (!aIdText.startsWith('.') && bIdText.startsWith('.')) {
        return -1;
      }

      return aIdText.localeCompare(bIdText);
    });

    this.pendingImportNodes = importNodes;
  }

  isFileForSchema(generatedSchema: GeneratedSchema) {
    return typeof this.config.schemaFilter === 'function'
      ? this.config.schemaFilter(generatedSchema)
      : (this.config.schemaFilter ?? true);
  }

  isFileForGeneratedClientFunction(generatedFunction: GeneratedClientFunction) {
    return typeof this.config.clientFunctionFilter === 'function'
      ? this.config.clientFunctionFilter(generatedFunction)
      : (this.config.clientFunctionFilter ?? true);
  }

  addNodes(...nodes: Node[]) {
    this.nodeList.push(...nodes);
  }

  getHasContent() {
    return Boolean(this.nodeList.length > 0 || this.rawContent?.trim().length);
  }

  async write(): Promise<WritableFile<TFileContentType, TConfig, TPlugin> | undefined> {
    if (!this.getHasContent()) {
      return undefined;
    }

    let preExistingContent: TFileContentType | undefined;

    try {
      preExistingContent = await this.getExistingFileContent();
    } catch {}

    this.generateImports();

    if (this.rawContent) {
      let writtenContent: TFileContentType | undefined;

      if (this.config.readExistingFile) {
        try {
          writtenContent = await this.config.readExistingFile(
            this.writePath,
            this.config.directory,
            this.config.fileName,
          );
        } catch {}
      }

      return {
        exportFromIndexFile: this.config.exportFromIndexFile,
        content: this.rawContent,
        writePath: this.writePath,
        directory: this.config.directory,
        fileName: this.config.fileName,
        wasWritten: false,
        preExistingContent: preExistingContent,
        writtenContent,
        writtenByPlugin: this.generatingPlugin,
      };
    }

    if (this.pendingImportNodes.length || this.pendingHeaderNodes.length) {
      this.generateBlankLine(true);
    }

    if (this.pendingImportNodes.length) {
      this.nodeList = [...this.pendingImportNodes, ...this.nodeList];
    }

    if (this.pendingHeaderNodes.length) {
      this.nodeList = [...this.pendingHeaderNodes, ...this.nodeList];
    }

    this.generateExports();

    const writtenFile: WritableFile<TFileContentType, TConfig, TPlugin> = {
      content: '',
      exportFromIndexFile: this.config.exportFromIndexFile,
      writePath: this.writePath,
      directory: this.config.directory,
      fileName: this.config.fileName,
      wasWritten: false,
      preExistingContent: preExistingContent,
      writtenContent: undefined,
      writtenByPlugin: this.generatingPlugin,
    };

    if (this.config.preBuildHook) {
      await this.config.preBuildHook(this, writtenFile);
    }

    writtenFile.content = this.printer.printList(
      ListFormat.MultiLine,
      factory.createNodeArray(this.nodeList),
      createSourceFile(
        this.config.fileName,
        '',
        ScriptTarget.ESNext,
        true,
        writtenFile.fileName.endsWith('.tsx') ? ScriptKind.TSX : ScriptKind.TS,
      ),
    );

    if (this.config.postBuildHook) {
      writtenFile.content = await this.config.postBuildHook(this, writtenFile);
    }

    if (this.config.readExistingFile) {
      try {
        writtenFile.writtenContent = await this.config.readExistingFile(
          this.writePath,
          this.config.directory,
          this.config.fileName,
        );
      } catch {}
    }

    return writtenFile;
  }
}
