import { ImportDeclaration, Node, ScriptTarget } from 'typescript';
import { ts, ScriptKind } from 'ts-morph';
import { match, P } from 'ts-pattern';
import { GeneratedImportPath, IPlugin, ManualExport, ManualImport } from '../types';
import { getImportPath } from '../../fs-helpers';
import { createImportDeclaration, createNamedExportDeclaration } from '../../helpers';
import { GeneratedClientFunction, GeneratedSchema } from '../../generated-types';
import { IPluginFileConfig, PluginFile } from './types';
import {
  defaultGeneratorFileConverter,
  defaultGeneratorFileReader,
  GeneratorFile,
  IWritableFile,
} from '../../file/types';

const { createPrinter, createSourceFile, factory, ListFormat, NewLineKind } = ts;

export class BasePluginFile<
  TFileContentType = string,
  TConfig extends IPluginFileConfig<TFileContentType> = IPluginFileConfig<TFileContentType>,
  TGenerator extends IPlugin<any, any, any> = IPlugin<any, any, any>,
> extends PluginFile<TFileContentType, TConfig, TGenerator> {
  nodeList: Node[] = [];
  readonly typeImports: Set<string> = new Set();
  readonly clientImports: Set<string> = new Set();
  readonly manualImports: Map<string, ManualImport> = new Map();
  readonly manualExports: Map<string | undefined, ManualExport> = new Map();
  rawContent: string | undefined;
  pendingHeaderNodes: Node[] = [];
  pendingImportNodes: Node[] = [];
  printer = createPrinter({ newLine: NewLineKind.LineFeed });

  constructor(
    generator: TGenerator,
    config: TConfig,
    generatedTypesImportConfiguration: GeneratedImportPath,
    generatedClientImportConfiguration: GeneratedImportPath,
    builtFilePath: string,
  ) {
    super(
      generator,
      {
        ...config,
        readExistingFile: config.readExistingFile ?? defaultGeneratorFileReader,
        convertStringContentToFileContentType:
          config.convertStringContentToFileContentType ?? defaultGeneratorFileConverter,
      },
      generatedTypesImportConfiguration,
      generatedClientImportConfiguration,
      builtFilePath,
    );
  }

  generateHeading(comment?: string) {
    this.pendingHeaderNodes = [
      factory.createJSDocComment(
        comment || `@generated by @pentops/jsonapi-jdef-ts-generator (Plugin: ${this.generator.name}) - do not edit`,
      ),
      factory.createIdentifier('\n'),
      ...this.pendingHeaderNodes,
    ];
  }

  generateBlankLine(writeToFront?: boolean) {
    const node = factory.createIdentifier('\n');

    if (writeToFront) {
      this.nodeList.unshift(node);
    } else {
      this.nodeList.push(node);
    }
  }

  addImportToOtherGeneratedFile<TToFile extends GeneratorFile = GeneratorFile>(
    file: TToFile,
    namedImports: string[] | undefined,
    typeOnlyNamedImports?: string[],
    defaultImport?: string,
  ) {
    if (file.config.directory === this.config.directory && file.config.fileName === this.config.fileName) {
      return;
    }

    this.addManualImport(
      getImportPath(file.config.directory, file.config.fileName, this.config.directory, this.config.fileName),
      namedImports,
      typeOnlyNamedImports,
      defaultImport,
    );
  }

  addManualImport(
    importPath: string,
    namedImports: string[] | undefined,
    typeOnlyNamedImports?: string[],
    defaultImport?: string,
  ) {
    const existingImport = this.manualImports.get(importPath);

    if (!existingImport) {
      this.manualImports.set(importPath, {
        namedImports,
        typeOnlyNamedImports,
        defaultImport,
      });
    } else {
      this.manualImports.set(importPath, {
        ...existingImport,
        defaultImport: defaultImport || existingImport.defaultImport,
        namedImports: namedImports
          ? Array.from(new Set([...(existingImport.namedImports || []), ...(namedImports || [])]))
          : existingImport.namedImports,
        typeOnlyNamedImports: typeOnlyNamedImports
          ? Array.from(new Set([...(existingImport.typeOnlyNamedImports || []), ...(typeOnlyNamedImports || [])]))
          : existingImport.typeOnlyNamedImports,
      });
    }
  }

  removeManualImport(importPath: string, namedImports: string[] | undefined, defaultImport?: string) {
    const existingImport = this.manualImports.get(importPath);

    if (!existingImport) {
      return;
    }

    this.manualImports.set(importPath, {
      ...existingImport,
      defaultImport: defaultImport === existingImport.defaultImport ? undefined : existingImport.defaultImport,
      namedImports: existingImport.namedImports?.filter(
        (namedImport) => !namedImports || !namedImports.includes(namedImport),
      ),
      typeOnlyNamedImports: existingImport.typeOnlyNamedImports?.filter(
        (namedImport) => !namedImports || !namedImports.includes(namedImport),
      ),
    });
  }

  removeImportToGeneratedFile<TToFile extends GeneratorFile = GeneratorFile>(
    file: TToFile,
    namedImports: string[] | undefined,
    defaultImport?: string,
  ) {
    if (file.config.directory === this.config.directory && file.config.fileName === this.config.fileName) {
      return;
    }

    this.removeManualImport(
      getImportPath(file.config.directory, file.config.fileName, this.config.directory, this.config.fileName),
      namedImports,
      defaultImport,
    );
  }

  addManualExport(exportPath: string | undefined, manualExport: ManualExport) {
    const existingExport = this.manualExports.get(exportPath);

    if (!existingExport) {
      this.manualExports.set(exportPath, manualExport);
    } else {
      this.manualExports.set(
        exportPath,
        match(manualExport)
          .with({ wildcard: true }, () => manualExport)
          .with({ namedExports: P.not(P.nullish) }, (e) => {
            const existingNamedExports = match(existingExport)
              .with({ namedExports: P.not(P.nullish) }, (e) => e.namedExports)
              .otherwise(() => []);
            const existingTypeOnlyExports = match(existingExport)
              .with({ typeOnlyExports: P.not(P.nullish) }, (e) => e.typeOnlyExports)
              .otherwise(() => []);

            return {
              namedExports: Array.from(new Set([...existingNamedExports, ...(e.namedExports || [])])),
              typeOnlyExports: Array.from(new Set([...existingTypeOnlyExports, ...(e.typeOnlyExports || [])])),
            };
          })
          .otherwise(() => existingExport),
      );
    }
  }

  addGeneratedTypeImport(typeName: string) {
    this.typeImports.add(typeName);
  }

  addGeneratedClientImport(clientFunctionName: string) {
    this.clientImports.add(clientFunctionName);
  }

  setRawContent(content: string) {
    this.rawContent = content;
  }

  generateExports() {
    const exportNodes: Node[] = [];

    for (const [exportPath, exportConfig] of this.manualExports) {
      const node = match(exportConfig)
        .with({ wildcard: true }, () =>
          exportPath
            ? factory.createExportDeclaration(
                undefined,
                false,
                undefined,
                factory.createStringLiteral(exportPath, true),
              )
            : undefined,
        )
        .with({ namedExports: P.not(P.nullish) }, (e) =>
          e.namedExports.length
            ? createNamedExportDeclaration(exportPath, e.namedExports, e.typeOnlyExports)
            : undefined,
        )
        .otherwise(() => undefined);

      if (node) {
        exportNodes.push(node);
      }
    }

    this.addNodes(...exportNodes);
  }

  generateImports() {
    const importNodes: ImportDeclaration[] = [];

    if (this.typeImports.size) {
      const importPath = match(this.generatedTypesImportConfiguration)
        .with({ importPath: P.string }, (p) => p.importPath)
        .with({ fileName: P.string, directory: P.string }, ({ directory: d, fileName: f }) =>
          getImportPath(d, f, this.config.directory, this.config.fileName),
        )
        .otherwise(() => undefined);

      if (!importPath) {
        throw new Error(
          `[jdef-ts-generator](${this.generator.name}): generatedTypesImportConfiguration is missing either importPath, or fileName and directory`,
        );
      }

      importNodes.push(createImportDeclaration(importPath, Array.from(this.typeImports)));
    }

    if (this.clientImports.size) {
      const importPath = match(this.generatedClientImportConfiguration)
        .with({ importPath: P.string }, (p) => p.importPath)
        .with({ fileName: P.string, directory: P.string }, ({ directory: d, fileName: f }) =>
          getImportPath(d, f, this.config.directory, this.config.fileName),
        )
        .otherwise(() => undefined);

      if (!importPath) {
        throw new Error(
          `[jdef-ts-generator](${this.generator.name}): generatedClientImportConfiguration is missing either importPath, or fileName and directory`,
        );
      }

      importNodes.push(createImportDeclaration(importPath, Array.from(this.clientImports)));
    }

    if (this.manualImports.size) {
      for (const [importPath, { namedImports, typeOnlyNamedImports, defaultImport }] of this.manualImports) {
        importNodes.push(createImportDeclaration(importPath, namedImports, typeOnlyNamedImports, defaultImport));
      }
    }

    importNodes.sort((a, b) => {
      const aIdText = ts.isStringLiteral(a.moduleSpecifier) ? a.moduleSpecifier.text : '';
      const bIdText = ts.isStringLiteral(b.moduleSpecifier) ? b.moduleSpecifier.text : '';

      if (aIdText.startsWith('.') && !bIdText.startsWith('.')) {
        return 1;
      }

      if (!aIdText.startsWith('.') && bIdText.startsWith('.')) {
        return -1;
      }

      return aIdText.localeCompare(bIdText);
    });

    this.pendingImportNodes = importNodes;
  }

  isFileForSchema(generatedSchema: GeneratedSchema) {
    return typeof this.config.schemaFilter === 'function'
      ? this.config.schemaFilter(generatedSchema)
      : (this.config.schemaFilter ?? true);
  }

  isFileForGeneratedClientFunction(generatedFunction: GeneratedClientFunction) {
    return typeof this.config.clientFunctionFilter === 'function'
      ? this.config.clientFunctionFilter(generatedFunction)
      : (this.config.clientFunctionFilter ?? true);
  }

  addNodes(...nodes: Node[]) {
    this.nodeList.push(...nodes);
  }

  getHasContent() {
    return Boolean(this.nodeList.length > 0 || this.rawContent?.trim().length);
  }

  async buildContent(): Promise<IWritableFile<TFileContentType> | undefined> {
    if (!this.getHasContent()) {
      return undefined;
    }

    const preExistingContent = (await this.pollForExistingFileContent())?.content;

    this.generateImports();

    if (this.rawContent) {
      let writtenContent: TFileContentType | undefined;

      if (this.config.convertStringContentToFileContentType) {
        try {
          writtenContent = await this.config.convertStringContentToFileContentType(this.rawContent);
        } catch {}
      }

      this._builtFile = {
        clearDirectoryBeforeWrite: Boolean(this.config.clearDirectoryBeforeWrite),
        exportFromIndexFile: this.config.exportFromIndexFile,
        content: this.rawContent,
        writePath: this.writePath,
        directory: this.config.directory,
        fileName: this.config.fileName,
        wasWritten: false,
        preExistingContent,
        writtenContent,
        writtenBy: this.generator,
      };

      return this._builtFile;
    }

    if (this.pendingImportNodes.length || this.pendingHeaderNodes.length) {
      this.generateBlankLine(true);
    }

    if (this.pendingImportNodes.length) {
      this.nodeList = [...this.pendingImportNodes, ...this.nodeList];
    }

    if (this.pendingHeaderNodes.length) {
      this.nodeList = [...this.pendingHeaderNodes, ...this.nodeList];
    }

    this.generateExports();

    this._builtFile = {
      content: '',
      clearDirectoryBeforeWrite: Boolean(this.config.clearDirectoryBeforeWrite),
      exportFromIndexFile: this.config.exportFromIndexFile,
      writePath: this.writePath,
      directory: this.config.directory,
      fileName: this.config.fileName,
      wasWritten: false,
      preExistingContent: preExistingContent,
      writtenContent: undefined,
      writtenBy: this.generator,
    };

    return this._builtFile;
  }

  async build(): Promise<IWritableFile<TFileContentType> | undefined> {
    await this.buildContent();

    if (this._builtFile === undefined) {
      console.warn(
        `[jdef-ts-generator](${this.generator.name}): file ${this.config.fileName} was not built before write attempted`,
      );

      return undefined;
    }

    if (this._builtFile === null) {
      return undefined;
    }

    this.generator.eventBus?.emit('preBuildFile', { file: this, fileToBuild: this._builtFile });

    this._builtFile.content =
      this._builtFile.content ||
      this.printer.printList(
        ListFormat.MultiLine,
        factory.createNodeArray(this.nodeList),
        createSourceFile(
          this.config.fileName,
          '',
          ScriptTarget.ESNext,
          true,
          this._builtFile.fileName.endsWith('.tsx') ? ScriptKind.TSX : ScriptKind.TS,
        ),
      );

    this.generator.eventBus?.emit('postBuildFile', { file: this, fileToBuild: this._builtFile });

    if (this.config.convertStringContentToFileContentType) {
      try {
        this._builtFile.writtenContent = await this.config.convertStringContentToFileContentType(
          this._builtFile.content,
        );
      } catch {}
    }

    return this._builtFile;
  }
}
