import url from 'url';
import { findUp } from 'find-up';
import { camelCase, pascalCase } from 'change-case';
import { PluginBase } from './plugin';
import { ParsedMethod } from './parsed-types';

export type SourceType = 'jdef' | 'api';

export interface HostedSource {
  // url is the url of the hosted jdef.json or api.json file
  url: string;
  // auth is the authentication configuration for the hosted jdef.json or api.json file, if applicable
  auth?: {
    token?: string;
  };
  type?: SourceType;
}

export interface HostedSourceService {
  service: HostedSource;
}

export interface LocalSourcePath {
  path: string;
  type?: SourceType;
}

export type JSONSource = HostedSourceService | LocalSourcePath;

interface TypeOutput {
  // fileName is the name of the generated types file
  fileName: `${string}.ts`;
  // directory is the directory where the generated types file will be saved
  directory: string;
  // importPath is the path that will be used to import the generated types file. If not specified, the import path will be relative to the current working directory.
  importPath?: string;
  topOfFileComment?: string;
}

const defaultTypeOutput: TypeOutput = {
  fileName: 'index.ts',
  directory: './generated/types',
  topOfFileComment: '@generated by @pentops/jsonapi-jdef-ts-generator - do not edit',
};

interface ClientOutput {
  // fileName is the name of the generated api client file
  fileName: `${string}.ts`;
  // directory is the directory where the generated api client file will be saved
  directory: string;
  // importPath is the path that will be used to import the generated client file. If not specified, the import path will be relative to the current working directory.
  importPath?: string;
  topOfFileComment?: string;
}

const defaultClientOutput: ClientOutput = {
  fileName: 'index.ts',
  directory: './generated/client',
  topOfFileComment: '@generated by @pentops/jsonapi-jdef-ts-generator - do not edit',
};

interface TypeGenerationConfig {
  // enumType set to union will generate union types for enums (e.g., 'test' | 'test2'), enum will generate enum types (e.g., enum Test { test = 'test', test2 = 'test2' })
  enumType: 'union' | 'enum';
  // nameWriter is a function that takes the name of a schema and returns the name of the generated type. Can be used to change the naming/casing conventions of the generated interfaces/enums.
  nameWriter: (name: string) => string;
  // requestType set to merged means that the search parameters, path parameters, and request body will be merged into a single type. When set to split, the search parameters, path parameters, and request body will be split into separate types.
  requestType: 'merged' | 'split';
}

interface ClientGenerationConfig {
  // methodNameWriter is a function that takes a jdef method and returns the name of the generated method. Can be used to change the naming/casing conventions of the generated functions.
  methodNameWriter: (method: ParsedMethod) => string;
}

export interface Config {
  // If dryRun is set to true, the generator will not write any files to disk. Output will be logged. Default is false.
  dryRun?: boolean;
  // generateIndexFiles set to false will prevent the generator from generating index files in the output directories. Default is true. If true, an index.ts file will be generated in the output directories that exports all generated types/functions. This behavior is disabled if one of the files is already an index file.
  generateIndexFiles?: boolean;
  typeOutput: TypeOutput;
  clientOutput?: ClientOutput;
  types: TypeGenerationConfig;
  client: ClientGenerationConfig;
  // plugins is an array of functions, which will be called after types and client functions have been generated, in order to enable additional codegen
  plugins?: PluginBase[];
  // jdefJsonSource is the source of the jdef.json file. Only one of service or path can be specified.
  jsonSource: JSONSource | JSONSource[];
}

export const defaultConfig: Config = {
  dryRun: false,
  generateIndexFiles: true,
  typeOutput: defaultTypeOutput,
  client: {
    methodNameWriter: (method: ParsedMethod) => camelCase(method.fullGrpcName),
  },
  types: {
    enumType: 'enum',
    nameWriter: (x) =>
      x
        .split('.')
        .map((s) => pascalCase(s))
        .join(''),
    requestType: 'merged',
  },
  jsonSource: {
    path: 'jdef.json',
  },
  plugins: [],
};

function mergeConfig(userSpecified: Partial<Config>): Config {
  const config: Config = { ...defaultConfig };

  if (userSpecified.dryRun) {
    config.dryRun = userSpecified.dryRun;
  }

  if (userSpecified.typeOutput) {
    config.typeOutput = { ...config.typeOutput, ...userSpecified.typeOutput };
  }

  if (userSpecified.clientOutput) {
    config.clientOutput = { ...config.clientOutput, ...defaultClientOutput, ...userSpecified.clientOutput };
  }

  if (userSpecified.types) {
    config.types = { ...config.types, ...userSpecified.types };
  }

  if (userSpecified.client) {
    config.client = { ...config.client, ...userSpecified.client };
  }

  if (userSpecified.plugins) {
    config.plugins = userSpecified.plugins;
  }

  // JSONSource is required
  if (userSpecified.jsonSource) {
    config.jsonSource = userSpecified.jsonSource;
  }

  return config;
}

export async function loadConfig(): Promise<Config> {
  const configJs = await findUp('.jdef_config.js');

  if (configJs) {
    const configModule = await import(url.pathToFileURL(configJs).href);

    if (configModule?.default) {
      return mergeConfig(configModule.default);
    }
  }

  console.warn('[jdef-ts-generator]: no .jdef_config.js file found, using default config');

  return defaultConfig;
}
